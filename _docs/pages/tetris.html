<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ†ãƒˆãƒªã‚¹ - PowerShell ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ</title>
    <link rel="stylesheet" href="../css/styles.css">
    <style>
        .game-container {
            text-align: center;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .start-screen {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            color: #333;
        }
        
        .start-screen h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            color: #00b894;
        }
        
        .instructions {
            background: rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .start-button {
            background: linear-gradient(45deg, #00b894, #00cec9);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        
        .start-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
        }
        
        .game-area {
            display: none;
            justify-content: center;
            gap: 30px;
            align-items: flex-start;
        }
        
        .game-canvas {
            border: 3px solid #a8edea;
            border-radius: 15px;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
        }
        
        .game-info {
            text-align: left;
            background: linear-gradient(135deg, #a8edea, #fed6e3);
            padding: 20px;
            border-radius: 15px;
            color: #333;
            min-width: 200px;
        }
        
        .next-piece {
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }
        
        .score-display {
            background: rgba(255,255,255,0.3);
            padding: 10px;
            border-radius: 10px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(168,237,234,0.95);
            color: #333;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        .restart-button {
            background: linear-gradient(45deg, #00b894, #00cec9);
            border: none;
            color: white;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }
        
        .restart-button:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="breadcrumb">
            <a href="../index.html">ãƒ›ãƒ¼ãƒ </a> &gt; ãƒ†ãƒˆãƒªã‚¹
        </nav>
        
        <header>
            <h1>ğŸ§© ãƒ†ãƒˆãƒªã‚¹</h1>
            <p>ãƒ–ãƒ­ãƒƒã‚¯ã‚’çµ„ã¿åˆã‚ã›ã¦ãƒ©ã‚¤ãƒ³ã‚’æ¶ˆãã†ï¼</p>
            <button class="theme-toggle" onclick="toggleTheme()">ğŸŒ™</button>
        </header>
        
        <div class="search-container">
            <input type="text" id="searchInput" placeholder="ã‚²ãƒ¼ãƒ å†…ã‚’æ¤œç´¢..." onkeyup="filterContent()">
        </div>
        
        <div class="game-container">
            <div class="start-screen" id="startScreen">
                <h2>ğŸŒŸ ãƒ†ãƒˆãƒªã‚¹ ğŸŒŸ</h2>
                <div class="instructions">
                    <h3>ğŸ® æ“ä½œæ–¹æ³•</h3>
                    <p><strong>â† â†’</strong> ã‚­ãƒ¼: ãƒ–ãƒ­ãƒƒã‚¯ã‚’å·¦å³ã«ç§»å‹•</p>
                    <p><strong>â†“</strong> ã‚­ãƒ¼: ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸‹ã«ç§»å‹•ï¼ˆã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ï¼‰</p>
                    <p><strong>â†‘</strong> ã‚­ãƒ¼: ãƒ–ãƒ­ãƒƒã‚¯ã‚’å›è»¢</p>
                    <p><strong>ã‚¹ãƒšãƒ¼ã‚¹</strong> ã‚­ãƒ¼: ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸€æ°—ã«ä¸‹ã«ç§»å‹•ï¼ˆãƒãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—ï¼‰</p>
                    <p><strong>C/Shift</strong> ã‚­ãƒ¼: ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ›ãƒ¼ãƒ«ãƒ‰</p>
                    <p><strong>1/2</strong> ã‚­ãƒ¼: ãƒ›ãƒ¼ãƒ«ãƒ‰ãƒ”ãƒ¼ã‚¹ã¨äº¤æ›</p>
                    <p><strong>P</strong> ã‚­ãƒ¼: ä¸€æ™‚åœæ­¢/å†é–‹</p>
                </div>
                <div class="instructions">
                    <h3>ğŸ¯ ã‚²ãƒ¼ãƒ ã®ç›®çš„</h3>
                    <p>è½ã¡ã¦ãã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‚’çµ„ã¿åˆã‚ã›ã¦ã€æ¨ªä¸€åˆ—ã‚’å®Œæˆã•ã›ã‚ˆã†ï¼</p>
                    <p>ãƒ©ã‚¤ãƒ³ãŒå®Œæˆã™ã‚‹ã¨æ¶ˆãˆã¦ã€ã‚¹ã‚³ã‚¢ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚</p>
                </div>
                <button class="start-button" onclick="startGame()">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼ ğŸ§©</button>
            </div>
            
            <div class="game-area" id="gameArea">
                <canvas id="gameCanvas" class="game-canvas" width="300" height="600"></canvas>
                
                <div class="game-info">
                    <h3>ğŸ“Š ã‚²ãƒ¼ãƒ æƒ…å ±</h3>
                    <div class="score-display">ã‚¹ã‚³ã‚¢: <span id="score">0</span></div>
                    <div class="score-display">ãƒ©ã‚¤ãƒ³: <span id="lines">0</span></div>
                    <div class="score-display">ãƒ¬ãƒ™ãƒ«: <span id="level">1</span></div>
                    
                    <div class="next-piece">
                        <h4>æ¬¡ã®ãƒ”ãƒ¼ã‚¹</h4>
                        <canvas id="nextCanvas" width="120" height="120"></canvas>
                    </div>

                    <div class="next-piece">
                        <h4>ãƒ›ãƒ¼ãƒ«ãƒ‰</h4>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <canvas id="holdCanvas1" width="60" height="60" style="border: 2px solid #333; border-radius: 5px;"></canvas>
                            <canvas id="holdCanvas2" width="60" height="60" style="border: 2px solid #333; border-radius: 5px;"></canvas>
                        </div>
                        <p style="font-size: 12px; margin: 5px 0;">C/Shift: ãƒ›ãƒ¼ãƒ«ãƒ‰</p>
                        <p style="font-size: 12px; margin: 5px 0;">1/2: äº¤æ›</p>
                    </div>
                    
                    <div class="score-display">
                        <h4>æ“ä½œèª¬æ˜</h4>
                        <p>â† â†’ : ç§»å‹•</p>
                        <p>â†‘ : å›è»¢</p>
                        <p>â†“ : ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—</p>
                        <p>ã‚¹ãƒšãƒ¼ã‚¹ : ãƒãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—</p>
                        <p>C/Shift : ãƒ›ãƒ¼ãƒ«ãƒ‰</p>
                        <p>1/2 : ãƒ›ãƒ¼ãƒ«ãƒ‰äº¤æ›</p>
                    </div>
                </div>
            </div>
            
            <div class="game-over" id="gameOver">
                <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
                <p>æœ€çµ‚ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
                <p>æ¶ˆå»ãƒ©ã‚¤ãƒ³: <span id="finalLines">0</span></p>
                <button class="restart-button" onclick="restartGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
                <button class="restart-button" onclick="showStartScreen()">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
            </div>
        </div>
    </div>
    
    <footer>
        <p><a href="../index.html">ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</a> | PowerShell ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ v1.0</p>
    </footer>
    
    <script src="../js/script.js"></script>
    <script>
        // ã‚²ãƒ¼ãƒ å¤‰æ•°
        let canvas, ctx, nextCanvas, nextCtx;
        let holdCanvas1, holdCtx1, holdCanvas2, holdCtx2;
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let lines = 0;
        let level = 1;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;

        // ãƒ›ãƒ¼ãƒ«ãƒ‰æ©Ÿèƒ½
        let holdPieces = [null, null];  // 2ã¤ã®ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆ
        let canHold = true;  // ãƒ›ãƒ¼ãƒ«ãƒ‰å¯èƒ½ãƒ•ãƒ©ã‚°
        let selectedHoldSlot = 0;  // é¸æŠä¸­ã®ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆ

        // ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 30;
        let board = [];

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
        let particles = [];
        let lineBreakAnimations = [];

        // ãƒ†ãƒˆãƒ­ãƒŸãƒï¼ˆãƒ†ãƒˆãƒªã‚¹ã®ãƒ”ãƒ¼ã‚¹ï¼‰
        const PIECES = [
            // Iãƒ”ãƒ¼ã‚¹
            [[1, 1, 1, 1]],
            // Oãƒ”ãƒ¼ã‚¹
            [[1, 1], [1, 1]],
            // Tãƒ”ãƒ¼ã‚¹
            [[0, 1, 0], [1, 1, 1]],
            // Sãƒ”ãƒ¼ã‚¹
            [[0, 1, 1], [1, 1, 0]],
            // Zãƒ”ãƒ¼ã‚¹
            [[1, 1, 0], [0, 1, 1]],
            // Jãƒ”ãƒ¼ã‚¹
            [[1, 0, 0], [1, 1, 1]],
            // Lãƒ”ãƒ¼ã‚¹
            [[0, 0, 1], [1, 1, 1]]
        ];

        const PIECE_COLORS = [
            '#00f5ff', // I - ã‚·ã‚¢ãƒ³
            '#ffff00', // O - ã‚¤ã‚¨ãƒ­ãƒ¼
            '#800080', // T - ãƒã‚¼ãƒ³ã‚¿
            '#00ff00', // S - ã‚°ãƒªãƒ¼ãƒ³
            '#ff0000', // Z - ãƒ¬ãƒƒãƒ‰
            '#0000ff', // J - ãƒ–ãƒ«ãƒ¼
            '#ffa500'  // L - ã‚ªãƒ¬ãƒ³ã‚¸
        ];

        // ç¾åœ¨ã®ãƒ”ãƒ¼ã‚¹
        let currentPiece = null;
        let nextPiece = null;

        // å…¥åŠ›ç®¡ç†
        const inputState = {
            moveLeft: false,
            moveRight: false,
            softDrop: false,
            rotate: false,
            hardDrop: false,
            pause: false
        };

        const keyDownState = {};
        const moveDelay = 100;  // ç§»å‹•é–‹å§‹ã¾ã§ã®é…å»¶
        const moveSpeed = 50;   // é€£ç¶šç§»å‹•ã®é€Ÿåº¦
        const lastMoveTime = {
            left: 0,
            right: 0,
            down: 0
        };
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameArea').style.display = 'flex';

            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            nextCanvas = document.getElementById('nextCanvas');
            nextCtx = nextCanvas.getContext('2d');
            holdCanvas1 = document.getElementById('holdCanvas1');
            holdCtx1 = holdCanvas1.getContext('2d');
            holdCanvas2 = document.getElementById('holdCanvas2');
            holdCtx2 = holdCanvas2.getContext('2d');

            initGame();
            requestAnimationFrame(gameLoop);
        }

        // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
        function initGame() {
            gameRunning = true;
            gamePaused = false;
            score = 0;
            lines = 0;
            level = 1;
            dropInterval = 1000;
            dropCounter = 0;
            lastTime = 0;

            // ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–
            board = [];
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                board[y] = [];
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    board[y][x] = null;
                }
            }

            // ãƒ›ãƒ¼ãƒ«ãƒ‰æ©Ÿèƒ½åˆæœŸåŒ–
            holdPieces = [null, null];
            canHold = true;
            selectedHoldSlot = 0;

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
            particles = [];
            lineBreakAnimations = [];

            // æœ€åˆã®ãƒ”ãƒ¼ã‚¹ç”Ÿæˆ
            nextPiece = createPiece();
            spawnNewPiece();

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
            setupInputHandlers();
        }

        // å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š
        function setupInputHandlers() {
            // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);

            // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }
        
        // ãƒ”ãƒ¼ã‚¹ç”Ÿæˆ
        function createPiece() {
            const pieceIndex = Math.floor(Math.random() * PIECES.length);
            return {
                shape: PIECES[pieceIndex],
                color: PIECE_COLORS[pieceIndex],
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(PIECES[pieceIndex][0].length / 2),
                y: 0,
                type: pieceIndex
            };
        }

        // æ–°ã—ã„ãƒ”ãƒ¼ã‚¹ç”Ÿæˆ
        function spawnNewPiece() {
            currentPiece = nextPiece;
            nextPiece = createPiece();

            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
            if (!canMove(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                gameOver();
            }
        }
        
        // ç§»å‹•å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
        function canMove(newX, newY, shape) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = newX + x;
                        const boardY = newY + y;

                        if (boardX < 0 || boardX >= BOARD_WIDTH ||
                            boardY >= BOARD_HEIGHT) {
                            return false;
                        }

                        if (boardY >= 0 && board[boardY][boardX]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        // ãƒ”ãƒ¼ã‚¹ã‚’ãƒœãƒ¼ãƒ‰ã«å›ºå®š
        function lockPiece() {
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardX = currentPiece.x + x;
                        const boardY = currentPiece.y + y;
                        if (boardY >= 0) {
                            board[boardY][boardX] = currentPiece.color;
                        }
                    }
                }
            }

            // ãƒ©ã‚¤ãƒ³æ¶ˆå»ãƒã‚§ãƒƒã‚¯
            const linesCleared = clearLines();
            if (linesCleared > 0) {
                updateScore(linesCleared);
            }

            // æ–°ã—ã„ãƒ”ãƒ¼ã‚¹ç”Ÿæˆ
            spawnNewPiece();

            // ãƒ›ãƒ¼ãƒ«ãƒ‰å¯èƒ½ã«æˆ»ã™
            canHold = true;
        }
        
        // ãƒ©ã‚¤ãƒ³æ¶ˆå»
        function clearLines() {
            let linesCleared = 0;
            let clearedRows = [];

            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== null)) {
                    // æ¶ˆå»ã™ã‚‹è¡Œã‚’è¨˜éŒ²
                    clearedRows.push(y);

                    // ç ´å£Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
                    createLineBreakAnimation(y);

                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        if (board[y][x]) {
                            createParticles(x * BLOCK_SIZE + BLOCK_SIZE / 2,
                                          y * BLOCK_SIZE + BLOCK_SIZE / 2,
                                          board[y][x]);
                        }
                    }

                    // ãƒ©ã‚¤ãƒ³ã‚’å‰Šé™¤
                    board.splice(y, 1);
                    board.unshift(new Array(BOARD_WIDTH).fill(null));
                    linesCleared++;
                    y++; // åŒã˜è¡Œã‚’ã‚‚ã†ä¸€åº¦ãƒã‚§ãƒƒã‚¯
                }
            }

            return linesCleared;
        }

        // ãƒ©ã‚¤ãƒ³ç ´å£Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
        function createLineBreakAnimation(row) {
            lineBreakAnimations.push({
                row: row,
                progress: 0,
                maxProgress: 30,
                flash: true
            });
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2,
                    color: color,
                    size: 3 + Math.random() * 4,
                    life: 1.0,
                    gravity: 0.15,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];

                // ä½ç½®æ›´æ–°
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += particle.gravity;

                // å›è»¢
                particle.rotation += particle.rotationSpeed;

                // æ¸›è¡°
                particle.life -= 0.02;
                particle.size *= 0.98;

                // å‰Šé™¤
                if (particle.life <= 0 || particle.y > canvas.height) {
                    particles.splice(i, 1);
                }
            }
        }

        // ãƒ©ã‚¤ãƒ³ç ´å£Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
        function updateLineBreakAnimations(deltaTime) {
            for (let i = lineBreakAnimations.length - 1; i >= 0; i--) {
                const anim = lineBreakAnimations[i];
                anim.progress++;

                if (anim.progress >= anim.maxProgress) {
                    lineBreakAnimations.splice(i, 1);
                }
            }
        }

        // ã‚¹ã‚³ã‚¢æ›´æ–°
        function updateScore(linesCleared) {
            lines += linesCleared;
            const points = [0, 100, 300, 500, 800];
            score += points[Math.min(linesCleared, 4)] * level;

            // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
            const newLevel = Math.floor(lines / 10) + 1;
            if (newLevel > level) {
                level = newLevel;
                dropInterval = Math.max(100, 1000 - (level - 1) * 100);
            }
        }
        
        // ã‚­ãƒ¼æŠ¼ä¸‹å‡¦ç†
        function handleKeyDown(e) {
            if (!gameRunning) return;

            // ã‚­ãƒ¼ãƒªãƒ”ãƒ¼ãƒˆã‚’ç„¡è¦–
            if (e.repeat) return;

            if (keyDownState[e.key]) return;
            keyDownState[e.key] = true;

            switch(e.key) {
                case 'ArrowLeft':
                    inputState.moveLeft = true;
                    lastMoveTime.left = 0;
                    movePiece(-1, 0);
                    break;
                case 'ArrowRight':
                    inputState.moveRight = true;
                    lastMoveTime.right = 0;
                    movePiece(1, 0);
                    break;
                case 'ArrowDown':
                    inputState.softDrop = true;
                    lastMoveTime.down = 0;
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case ' ':
                    hardDrop();
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
                case 'c':
                case 'C':
                case 'Shift':
                    holdCurrentPiece();
                    break;
                case '1':
                    swapWithHold(0);
                    break;
                case '2':
                    swapWithHold(1);
                    break;
            }

            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' '].includes(e.key)) {
                e.preventDefault();
            }
        }

        // ã‚­ãƒ¼é›¢ä¸Šå‡¦ç†
        function handleKeyUp(e) {
            keyDownState[e.key] = false;

            switch(e.key) {
                case 'ArrowLeft':
                    inputState.moveLeft = false;
                    break;
                case 'ArrowRight':
                    inputState.moveRight = false;
                    break;
                case 'ArrowDown':
                    inputState.softDrop = false;
                    break;
            }
        }

        // ä¸€æ™‚åœæ­¢åˆ‡ã‚Šæ›¿ãˆ
        function togglePause() {
            gamePaused = !gamePaused;
        }

        // ãƒ›ãƒ¼ãƒ«ãƒ‰æ©Ÿèƒ½
        function holdCurrentPiece() {
            if (!canHold || !currentPiece || gamePaused) return;

            // ç©ºã„ã¦ã„ã‚‹ã‚¹ãƒ­ãƒƒãƒˆã‚’æ¢ã™
            let targetSlot = -1;
            if (holdPieces[0] === null) {
                targetSlot = 0;
            } else if (holdPieces[1] === null) {
                targetSlot = 1;
            } else {
                // ä¸¡æ–¹åŸ‹ã¾ã£ã¦ã„ã‚‹å ´åˆã¯é¸æŠä¸­ã®ã‚¹ãƒ­ãƒƒãƒˆã¨äº¤æ›
                targetSlot = selectedHoldSlot;
            }

            // ãƒ›ãƒ¼ãƒ«ãƒ‰å‡¦ç†
            const temp = holdPieces[targetSlot];
            holdPieces[targetSlot] = {
                shape: currentPiece.shape,
                color: currentPiece.color,
                type: currentPiece.type
            };

            if (temp) {
                // æ—¢å­˜ã®ãƒ›ãƒ¼ãƒ«ãƒ‰ãƒ”ãƒ¼ã‚¹ãŒã‚ã‚‹å ´åˆã¯äº¤æ›
                currentPiece = {
                    ...temp,
                    x: Math.floor(BOARD_WIDTH / 2) - Math.floor(temp.shape[0].length / 2),
                    y: 0
                };
                // é…ç½®å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                if (!canMove(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                    // é…ç½®ä¸å¯èƒ½ãªå ´åˆã¯å…ƒã«æˆ»ã™
                    holdPieces[targetSlot] = temp;
                    currentPiece = {
                        shape: holdPieces[targetSlot].shape,
                        color: holdPieces[targetSlot].color,
                        type: holdPieces[targetSlot].type,
                        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(holdPieces[targetSlot].shape[0].length / 2),
                        y: 0
                    };
                    return;
                }
            } else {
                // ãƒ›ãƒ¼ãƒ«ãƒ‰ãƒ”ãƒ¼ã‚¹ãŒãªã„å ´åˆã¯æ–°ã—ã„ãƒ”ãƒ¼ã‚¹ã‚’ç”Ÿæˆ
                spawnNewPiece();
            }

            canHold = false;
            // æ¬¡ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’é¸æŠ
            selectedHoldSlot = (selectedHoldSlot + 1) % 2;
        }

        // ç‰¹å®šã®ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆã¨äº¤æ›
        function swapWithHold(slotIndex) {
            if (!currentPiece || gamePaused || !holdPieces[slotIndex]) return;

            const temp = holdPieces[slotIndex];
            holdPieces[slotIndex] = {
                shape: currentPiece.shape,
                color: currentPiece.color,
                type: currentPiece.type
            };

            currentPiece = {
                ...temp,
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(temp.shape[0].length / 2),
                y: 0
            };

            // é…ç½®å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            if (!canMove(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                // é…ç½®ä¸å¯èƒ½ãªå ´åˆã¯å…ƒã«æˆ»ã™
                const original = holdPieces[slotIndex];
                holdPieces[slotIndex] = temp;
                currentPiece = {
                    shape: original.shape,
                    color: original.color,
                    type: original.type,
                    x: Math.floor(BOARD_WIDTH / 2) - Math.floor(original.shape[0].length / 2),
                    y: 0
                };
                return;
            }

            canHold = false;
            selectedHoldSlot = slotIndex;
        }

        // ç¾åœ¨ã®ãƒ”ãƒ¼ã‚¹ã‚’ãƒ›ãƒ¼ãƒ«ãƒ‰
        function holdCurrentPiece() {
            if (!canHold || !currentPiece || gamePaused) return;

            // ç©ºã„ã¦ã„ã‚‹ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆã‚’æ¢ã™
            let targetSlot = -1;
            if (holdPieces[0] === null) {
                targetSlot = 0;
            } else if (holdPieces[1] === null) {
                targetSlot = 1;
            } else {
                // ä¸¡æ–¹åŸ‹ã¾ã£ã¦ã„ã‚‹å ´åˆã¯ã€é¸æŠä¸­ã®ã‚¹ãƒ­ãƒƒãƒˆã¨äº¤æ›
                targetSlot = selectedHoldSlot;
            }

            if (targetSlot === -1) return;

            // ãƒ›ãƒ¼ãƒ«ãƒ‰ãƒ”ãƒ¼ã‚¹ã¨ç¾åœ¨ã®ãƒ”ãƒ¼ã‚¹ã‚’äº¤æ›
            const temp = holdPieces[targetSlot];
            holdPieces[targetSlot] = {
                shape: currentPiece.shape,
                color: currentPiece.color,
                type: currentPiece.type
            };

            if (temp !== null) {
                // ãƒ›ãƒ¼ãƒ«ãƒ‰ãƒ”ãƒ¼ã‚¹ãŒã‚ã£ãŸå ´åˆã¯äº¤æ›
                currentPiece = {
                    ...temp,
                    x: Math.floor(BOARD_WIDTH / 2) - Math.floor(temp.shape[0].length / 2),
                    y: 0
                };

                // äº¤æ›ã—ãŸãƒ”ãƒ¼ã‚¹ãŒé…ç½®å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                if (!canMove(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                    // é…ç½®ä¸å¯èƒ½ãªå ´åˆã¯å…ƒã«æˆ»ã™
                    holdPieces[targetSlot] = temp;
                    return;
                }
            } else {
                // ãƒ›ãƒ¼ãƒ«ãƒ‰ãƒ”ãƒ¼ã‚¹ãŒãªã‹ã£ãŸå ´åˆã¯æ–°ã—ã„ãƒ”ãƒ¼ã‚¹ã‚’ç”Ÿæˆ
                spawnNewPiece();
            }

            canHold = false;  // åŒã˜ãƒ”ãƒ¼ã‚¹ã‚’é€£ç¶šã§ãƒ›ãƒ¼ãƒ«ãƒ‰ã§ããªã„ã‚ˆã†ã«ã™ã‚‹
            selectedHoldSlot = (selectedHoldSlot + 1) % 2;  // æ¬¡ã®ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆã‚’é¸æŠ
        }

        // ç‰¹å®šã®ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆã¨äº¤æ›
        function swapWithHold(slotIndex) {
            if (!currentPiece || gamePaused || holdPieces[slotIndex] === null) return;

            const temp = holdPieces[slotIndex];
            holdPieces[slotIndex] = {
                shape: currentPiece.shape,
                color: currentPiece.color,
                type: currentPiece.type
            };

            currentPiece = {
                ...temp,
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(temp.shape[0].length / 2),
                y: 0
            };

            // äº¤æ›ã—ãŸãƒ”ãƒ¼ã‚¹ãŒé…ç½®å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            if (!canMove(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                // é…ç½®ä¸å¯èƒ½ãªå ´åˆã¯å…ƒã«æˆ»ã™
                holdPieces[slotIndex] = temp;
                currentPiece = {
                    shape: holdPieces[slotIndex].shape,
                    color: holdPieces[slotIndex].color,
                    type: holdPieces[slotIndex].type,
                    x: Math.floor(BOARD_WIDTH / 2) - Math.floor(holdPieces[slotIndex].shape[0].length / 2),
                    y: 0
                };
                return;
            }

            canHold = false;  // äº¤æ›å¾Œã¯ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚’ä¸€æ™‚çš„ã«ç„¡åŠ¹åŒ–
            selectedHoldSlot = slotIndex;
        }
        
        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop(currentTime) {
            if (!gameRunning) return;

            if (!lastTime) {
                lastTime = currentTime;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            if (!gamePaused) {
                update(deltaTime);
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        // ã‚²ãƒ¼ãƒ æ›´æ–°
        function update(deltaTime) {
            // é€£ç¶šç§»å‹•å‡¦ç†
            handleContinuousInput(deltaTime);

            // è‡ªå‹•è½ä¸‹
            const dropSpeed = inputState.softDrop ? 50 : dropInterval;
            dropCounter += deltaTime;

            if (dropCounter > dropSpeed) {
                dropCounter = 0;
                if (!movePiece(0, 1)) {
                    lockPiece();
                }
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            updateParticles(deltaTime);

            // ãƒ©ã‚¤ãƒ³ç ´å£Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            updateLineBreakAnimations(deltaTime);
        }

        // é€£ç¶šå…¥åŠ›å‡¦ç†
        function handleContinuousInput(deltaTime) {
            // å·¦ç§»å‹•
            if (inputState.moveLeft) {
                lastMoveTime.left += deltaTime;
                if (lastMoveTime.left > moveDelay) {
                    if ((lastMoveTime.left - moveDelay) % moveSpeed < deltaTime) {
                        movePiece(-1, 0);
                    }
                }
            }

            // å³ç§»å‹•
            if (inputState.moveRight) {
                lastMoveTime.right += deltaTime;
                if (lastMoveTime.right > moveDelay) {
                    if ((lastMoveTime.right - moveDelay) % moveSpeed < deltaTime) {
                        movePiece(1, 0);
                    }
                }
            }
        }
        
        // ãƒ”ãƒ¼ã‚¹ç§»å‹•
        function movePiece(dx, dy) {
            if (!currentPiece) return false;

            const newX = currentPiece.x + dx;
            const newY = currentPiece.y + dy;

            if (canMove(newX, newY, currentPiece.shape)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                return true;
            }
            return false;
        }

        // ãƒ”ãƒ¼ã‚¹å›è»¢
        function rotatePiece() {
            if (!currentPiece || gamePaused) return;

            const rotated = rotate(currentPiece.shape);

            // é€šå¸¸ã®å›è»¢ã‚’è©¦ã¿ã‚‹
            if (canMove(currentPiece.x, currentPiece.y, rotated)) {
                currentPiece.shape = rotated;
                return;
            }

            // Wall kick - å·¦å³ã«ç§»å‹•ã—ã¦å›è»¢ã‚’è©¦ã¿ã‚‹
            const kicks = [-1, 1, -2, 2];
            for (const kick of kicks) {
                if (canMove(currentPiece.x + kick, currentPiece.y, rotated)) {
                    currentPiece.x += kick;
                    currentPiece.shape = rotated;
                    return;
                }
            }
        }

        // å›è»¢å‡¦ç†
        function rotate(shape) {
            const rows = shape.length;
            const cols = shape[0].length;
            const rotated = [];

            for (let x = 0; x < cols; x++) {
                rotated[x] = [];
                for (let y = rows - 1; y >= 0; y--) {
                    rotated[x][rows - 1 - y] = shape[y][x];
                }
            }

            return rotated;
        }

        // ãƒãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—
        function hardDrop() {
            if (!currentPiece || gamePaused) return;

            let dropDistance = 0;
            while (movePiece(0, 1)) {
                dropDistance++;
            }
            score += dropDistance * 2;
            lockPiece();
        }
        
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLines').textContent = lines;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // æç”»å‡¦ç†
        function draw() {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ã‚°ãƒªãƒƒãƒ‰æç”»
            drawGrid();

            // ãƒœãƒ¼ãƒ‰ä¸Šã®ãƒ–ãƒ­ãƒƒã‚¯æç”»
            drawBoard();

            // ã‚´ãƒ¼ã‚¹ãƒˆãƒ”ãƒ¼ã‚¹æç”»
            drawGhost();

            // ç¾åœ¨ã®ãƒ”ãƒ¼ã‚¹æç”»
            drawCurrentPiece();

            // ãƒ©ã‚¤ãƒ³ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»
            drawLineBreakEffects();

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»
            drawParticles();

            // æ¬¡ã®ãƒ”ãƒ¼ã‚¹æç”»
            drawNextPiece();

            // ãƒ›ãƒ¼ãƒ«ãƒ‰ãƒ”ãƒ¼ã‚¹æç”»
            drawHoldPieces();

            // UIæ›´æ–°
            updateUI();
        }

        // ã‚°ãƒªãƒƒãƒ‰æç”»
        function drawGrid() {
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 0.5;

            for (let x = 0; x <= BOARD_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= BOARD_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
        }

        // ãƒœãƒ¼ãƒ‰æç”»
        function drawBoard() {
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (board[y][x]) {
                        drawBlock(x, y, board[y][x]);
                    }
                }
            }
        }

        // ãƒ–ãƒ­ãƒƒã‚¯æç”»
        function drawBlock(x, y, color, alpha = 1) {
            ctx.fillStyle = color;
            ctx.globalAlpha = alpha;
            ctx.fillRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);

            // ãƒã‚¤ãƒ©ã‚¤ãƒˆåŠ¹æœ
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 2, 4);
            ctx.fillRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, 4, BLOCK_SIZE - 2);

            ctx.globalAlpha = 1;
        }

        // ç¾åœ¨ã®ãƒ”ãƒ¼ã‚¹æç”»
        function drawCurrentPiece() {
            if (!currentPiece) return;

            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardX = currentPiece.x + x;
                        const boardY = currentPiece.y + y;
                        if (boardY >= 0) {
                            drawBlock(boardX, boardY, currentPiece.color);
                        }
                    }
                }
            }
        }

        // ã‚´ãƒ¼ã‚¹ãƒˆãƒ”ãƒ¼ã‚¹æç”»
        function drawGhost() {
            if (!currentPiece) return;

            let ghostY = currentPiece.y;
            while (canMove(currentPiece.x, ghostY + 1, currentPiece.shape)) {
                ghostY++;
            }

            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardX = currentPiece.x + x;
                        const boardY = ghostY + y;
                        if (boardY >= 0 && boardY !== currentPiece.y + y) {
                            drawBlock(boardX, boardY, currentPiece.color, 0.3);
                        }
                    }
                }
            }
        }

        // æ¬¡ã®ãƒ”ãƒ¼ã‚¹æç”»
        function drawNextPiece() {
            if (!nextPiece) return;

            nextCtx.fillStyle = '#2c3e50';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            const blockSize = 20;
            const offsetX = (nextCanvas.width - nextPiece.shape[0].length * blockSize) / 2;
            const offsetY = (nextCanvas.height - nextPiece.shape.length * blockSize) / 2;

            for (let y = 0; y < nextPiece.shape.length; y++) {
                for (let x = 0; x < nextPiece.shape[y].length; x++) {
                    if (nextPiece.shape[y][x]) {
                        nextCtx.fillStyle = nextPiece.color;
                        nextCtx.fillRect(
                            offsetX + x * blockSize + 1,
                            offsetY + y * blockSize + 1,
                            blockSize - 2,
                            blockSize - 2
                        );

                        // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                        nextCtx.fillStyle = 'rgba(255,255,255,0.3)';
                        nextCtx.fillRect(
                            offsetX + x * blockSize + 1,
                            offsetY + y * blockSize + 1,
                            blockSize - 2,
                            4
                        );
                    }
                }
            }
        }

        // ãƒ›ãƒ¼ãƒ«ãƒ‰ãƒ”ãƒ¼ã‚¹æç”»
        function drawHoldPieces() {
            // ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆ1
            drawPieceOnCanvas(holdPieces[0], holdCtx1, holdCanvas1, selectedHoldSlot === 0);

            // ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆ2
            drawPieceOnCanvas(holdPieces[1], holdCtx2, holdCanvas2, selectedHoldSlot === 1);
        }

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒ”ãƒ¼ã‚¹ã‚’æç”»
        function drawPieceOnCanvas(piece, ctx, canvas, isSelected) {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // é¸æŠä¸­ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            if (isSelected) {
                ctx.strokeStyle = '#00cec9';
                ctx.lineWidth = 2;
                ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
            }

            if (!piece) return;

            const blockSize = 12;
            const offsetX = (canvas.width - piece.shape[0].length * blockSize) / 2;
            const offsetY = (canvas.height - piece.shape.length * blockSize) / 2;

            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        ctx.fillStyle = piece.color;
                        ctx.fillRect(
                            offsetX + x * blockSize + 1,
                            offsetY + y * blockSize + 1,
                            blockSize - 2,
                            blockSize - 2
                        );

                        // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        ctx.fillRect(
                            offsetX + x * blockSize + 1,
                            offsetY + y * blockSize + 1,
                            blockSize - 2,
                            2
                        );
                    }
                }
            }
        }

        // ãƒ©ã‚¤ãƒ³ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»
        function drawLineBreakEffects() {
            lineBreakAnimations.forEach(anim => {
                if (anim.flash && anim.progress < 10) {
                    // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥åŠ¹æœ
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * (1 - anim.progress / 10)})`;
                    ctx.fillRect(0, anim.row * BLOCK_SIZE, canvas.width, BLOCK_SIZE);
                }

                // æ³¢ç´‹åŠ¹æœ
                const waveIntensity = Math.sin((anim.progress / anim.maxProgress) * Math.PI) * 10;
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const offsetY = Math.sin((x + anim.progress) * 0.5) * waveIntensity;
                    if (board[anim.row] && board[anim.row][x]) {
                        ctx.save();
                        ctx.translate(0, offsetY);
                        drawBlock(x, anim.row, board[anim.row][x], 1 - (anim.progress / anim.maxProgress) * 0.5);
                        ctx.restore();
                    }
                }
            });
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»
        function drawParticles() {
            particles.forEach(particle => {
                ctx.save();
                ctx.translate(particle.x, particle.y);
                ctx.rotate(particle.rotation);
                ctx.globalAlpha = particle.life;

                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç«‹æ–¹ä½“é¢¨ã«æç”»
                ctx.fillStyle = particle.color;
                ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);

                // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size * 0.3, particle.size * 0.3);

                ctx.restore();
            });
        }

        // UIæ›´æ–°
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
        }
        
        // ã‚²ãƒ¼ãƒ å†é–‹
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';

            // ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            if (holdCtx1 && holdCtx2) {
                holdCtx1.fillStyle = '#2c3e50';
                holdCtx1.fillRect(0, 0, holdCanvas1.width, holdCanvas1.height);
                holdCtx2.fillStyle = '#2c3e50';
                holdCtx2.fillRect(0, 0, holdCanvas2.width, holdCanvas2.height);
            }

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªã‚¢
            particles = [];
            lineBreakAnimations = [];

            initGame();
            requestAnimationFrame(gameLoop);
        }

        // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢è¡¨ç¤º
        function showStartScreen() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            document.getElementById('gameArea').style.display = 'none';

            gameRunning = false;

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
        }
        
        // æ¤œç´¢æ©Ÿèƒ½
        function filterContent() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            // ã‚²ãƒ¼ãƒ å†…ã®æ¤œç´¢æ©Ÿèƒ½ï¼ˆå¿…è¦ã«å¿œã˜ã¦å®Ÿè£…ï¼‰
        }
    </script>
</body>
</html>
